#Board Setup
#4x4 Sudoku
#[[?,?,?,4],[?,?,?,?],[2,?,?,3],[4,?,1,2]
import os
os.system('clear')

import pandas as pd
import math as math
import numpy as np

#Required functions
def poss_str_to_poss_lst(poss_string):
  import re
  poss_lst = []
  poss_string_split = poss_string.split(',')
  for i in poss_string_split:
    poss_lst.append(int(re.sub(r'[^0-9]', '', i)))
  return poss_lst

def box_picker(i,j,dim):
  if dim == 9:
    if i <=2:
      box = 0
    elif i > 2 and i <= 5:
      box = 3
    elif i > 5 and i <= 8:
      box = 6
    if j <=2:
      box += 1
    elif j > 2 and j <= 5:
      box += 2
    elif j > 5 and j <= 8:
      box += 3
  return box

def box_corner_row(box):
  if box <=3:
    box_corner_row = 0
  elif box >3 and box <=6:
    box_corner_row = 3
  elif box >6 and box <=9:
    box_corner_row = 6
  return box_corner_row

def box_corner_col(box):
  if box % 3 == 1:
    box_corner_col = 0
  elif box % 3 == 2:
    box_corner_col = 3
  elif box % 3 == 0:
    box_corner_col = 6
  return box_corner_col

def quality_checker(df):
  problem = 0
  for i in range(0,shape[0]):
    in_array = []
    for j in range(0,shape[0]):
      if type(df.iloc[i,j]) is int:
        if df.iloc[i,j] not in in_array:
          in_array.append(df.iloc[i,j])
        else:
          print('Critical problem with implemented logic - duplicate ',df.iloc[i,j],'in row',i)
          problem = 1
  for j in range(0,shape[0]):
    in_array = []
    for i in range(0,shape[0]):
      if type(df.iloc[i,j]) is int:
        if df.iloc[i,j] not in in_array:
          in_array.append(df.iloc[i,j])
        else:
          print('Critical problem with implemented logic - duplicate ',df.iloc[i,j],'in col',j)
          problem = 1
  return problem
  
  
      




#Data input template
#data = {
#  "col1": [None,],
#  "col2": [None,],
#  "col3": [None,],
#  "col4": [None,],
#  "col5": [None,],
#  "col6": [None,],
#  "col7": [None,],
#  "col8": [None,],
#  "col9": [None,]
#}

data_supereasy = {
  "col1": [None,4,None,None,7,9,None,3,None],
  "col2": [None,None,6,8,None,None,5,2,None],
  "col3": [3,2,None,4,None,None,7,None,8],
  "col4": [7,None,None,None,8,None,3,None,1],
  "col5": [None,None,9,None,2,None,None,4,None],
  "col6": [None,None,8,6,1,5,None,None,9],
  "col7": [None,6,None,None,None,None,9,1,7],
  "col8": [1,8,4,None,9,2,6,5,None,],
  "col9": [5,None,None,None,None,3,4,None,None]
}
data_easy = {
  "col1": [None,None,8,None,6,None,None,None,None],
  "col2": [9,None,None,8,None,None,None,7,6],
  "col3": [None,6,5,3,None,None,9,None,None],
  "col4": [8,5,None,None,None,3,6,None,None],
  "col5": [None,9,None,None,None,None,None,3,None],
  "col6": [None,None,6,1,None,None,None,5,7],
  "col7": [None,None,1,None,None,7,4,6,None],
  "col8": [2,4,None,None,None,1,None,None,3],
  "col9": [None,None,None,None,2,None,1,None,None]
}

data_med = {
  "col1": [None,None,9,None,None,None,4,None,None],
  "col2": [None,2,None,9,None,3,7,None,None],
  "col3": [None,None,7,None,6,1,None,None,8],
  "col4": [None,5,3,None,None,4,9,None,None],
  "col5": [None,None,None,None,None,None,None,None,None],
  "col6": [None,None,6,5,None,None,8,3,None],
  "col7": [9,None,None,2,1,None,3,None,None],
  "col8": [None,None,2,8,None,6,None,7,None],
  "col9": [None,None,1,None,None,None,6,None,None]
}

data_hard = {
  "col1": [4,5,None,2,None,None,None,None,None],
  "col2": [None,None,None,None,None,None,6,2,None],
  "col3": [None,None,2,None,1,7,None,3,None],
  "col4": [None,None,8,None,3,None,7,None,None],
  "col5": [None,None,7,None,None,1,4,None,None],
  "col6": [2,6,None,None,None,None,None,None,9],
  "col7": [None,3,None,None,5,8,2,None,None],
  "col8": [None,None,4,3,None,None,None,None,8],
  "col9": [None,None,None,1,None,None,None,None,3]
}

data = data_med

#load data into a DataFrame object:
df = pd.DataFrame(data)
print(df)

#Get shape of dataframe
shape = df.shape
#number of cols
#print(shape[0])
#number of rows
#print(shape[1])

#to reference an individual column, row, element in an array
row = df.iloc[:,3]
col = df.iloc[1,:]
element = df.iloc[2,2]

#Create a base possibiilities dataframe - mutliple possibilities need to be stored as a string
possibilities_df = df.astype(object)

NaNcount=0
lst = list(range(1,shape[0]+1))
for i in range(0,shape[0]):
  for j in range(0,shape[1]):
    if possibilities_df.iloc[i,j] == None or math.isnan(possibilities_df.iloc[i,j]) == True:
      NaNcount += 1
      possibilities_df.iloc[i,j] = str(lst)
    else:
      possibilities_df.iloc[i,j] = int(possibilities_df.iloc[i,j])
#print(possibilities_df)
possibilities_df_orig = possibilities_df

#Overall looper, puzzle loops until is_done=1
is_done = 0
count=0
solving_step=0

#os.system('clear')

while is_done == 0:
  if count >= 500:
    print('The puzzle has not been solved after 500+ steps')
    count += 1
    print('Final state after', count, 'steps')
    print(possibilities_df)
    is_done = 1
  elif NaNcount == 0: 
    is_done=1
    print('The puzzle is done after',count,'steps')
  else:
    #For each element, rule out potential possibiltiies if that possibility is already in row/col
    for i in range(0,shape[0]):
      for j in range(0,shape[1]):
        if type(possibilities_df.iloc[i,j]) is str:
          poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
          for x in possibilities_df.iloc[i,:]:
            if type(x) is int and x in poss_lst:
              poss_lst.remove(x)
          for y in possibilities_df.iloc[:,j]:
            if type(y) is int and y in poss_lst:
              poss_lst.remove(y)
          
          box = box_picker(i,j,shape[0])
          b_row = box_corner_row(box)
          b_col = box_corner_col(box)
          #iterate for three elements of each of three rows (i.e. the box)
          for z in possibilities_df.iloc[b_row:b_row+3,b_col]:
            if type(z) is int and z in poss_lst:
              poss_lst.remove(z)
          for z in possibilities_df.iloc[b_row:b_row+3,b_col+1]:
            if type(z) is int and z in poss_lst:
              poss_lst.remove(z)
          for z in possibilities_df.iloc[b_row:b_row+3,b_col+2]:
            if type(z) is int and z in poss_lst:
              poss_lst.remove(z)
          
          #If there is only one element in poss_lst, then this has to be the answer
          if len(poss_lst) == 1:
            possibilities_df.iloc[i,j] = int(poss_lst[0])  
            NaNcount -= 1
            solving_step += 1
            print('Solving Step #',solving_step)
            print('Set element',i,',',j,'in box',box,'to',str(poss_lst[0]),'as it was the only potential value for that element')
            print(possibilities_df)
            if quality_checker(possibilities_df) == 1:
              print('ARRGH')
          else:
            possibilities_df.iloc[i,j] = str(poss_lst)
            if poss_lst ==[]:
              print('big problem of empty possibilities list')
      count += 1            
      #input additional logic to solve puzzle
      #e.g. existing tuples and higher level logic
    
    #Examine each row to see if there are any numbers which can only go in one location
    skip=0 #Kill-switch for this section
    if skip==0:
      for i in range(0,shape[0]):
        for k in range(1,10):
          k_count=0
          k_skip=0
          for j in range(0,shape[1]):
            if possibilities_df.iloc[i,j] == k:
              k_skip = 1 #If k is already present as an integer, skip all future steps for this k
              k_count = 0
            elif type(possibilities_df.iloc[i,j]) is str and k_skip == 0:
              poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
              if k in poss_lst:
                k_count += 1
            
          if k_count == 1 and k_skip == 0:
            for j in range(0,shape[1]):
              if type(possibilities_df.iloc[i,j]) is str:
                poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
                if k in poss_lst:
                  possibilities_df.iloc[i,j] = int(k)
                  NaNcount -= 1
                  solving_step += 1
                  print('Solving Step #',solving_step)
                  print(possibilities_df)
      count += 1    
    
    #Examine each col to see if there are any numbers which can only go in one location
    skip=0 #Kill-switch for this section
    if skip==0:
      for j in range(0,shape[1]):
        for k in range(1,10):
          k_count=0
          k_skip=0
          for i in range(0,shape[0]):
            if possibilities_df.iloc[i,j] == int(k):
                k_skip = 1 #If k is already present as an integer, skip all future steps for this k
                k_count = 0
            elif type(possibilities_df.iloc[i,j]) is str and k_skip == 0:
              poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
              if k in poss_lst:
                k_count += 1
            
          if k_count == 1 and k_skip == 0:
            for i in range(0,shape[0]):
              if type(possibilities_df.iloc[i,j]) is str:
                poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
                if k in poss_lst:
                  possibilities_df.iloc[i,j] = int(k)
                  NaNcount -= 1
                  solving_step +=1
                  print('Solving Step #',solving_step)
                  print(possibilities_df)      
      count += 1
    
    #Examine each box to see if there are any numbers which can only go in one location
    skip=0 #Kill-switch for this section
    if skip==0:
      for box in range(1,shape[0]+1):
      #box = 9
        b_row = box_corner_row(box)
        b_col = box_corner_col(box)
        for k in list(range(1,10)):
          k_count = 0
          k_skip = 0 
          for bx in range(0,3):
            for by in range(0,3):
              if possibilities_df.iloc[b_row+bx,b_col+by] == int(k):
                k_skip = 1 #If k is already present as an integer, skip all future steps for this k
                k_count = 0
              if type(possibilities_df.iloc[b_row+bx,b_col+by]) is str and k_skip == 0:
                poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[b_row+bx,b_col+by])
                if k in poss_lst:
                  k_count += 1
              elif possibilities_df.iloc[b_row+bx,b_col+by] == k:
                k_count = 0
          
          if k_count == 1 and k_skip == 0:
            for bx in range(0,3):
              for by in range(0,3):
                if type(possibilities_df.iloc[b_row+bx,b_col+by]) is str:
                  poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[b_row+bx,b_col+by])
                  if k in poss_lst:
                    possibilities_df.iloc[b_row+bx,b_col+by] = int(k)
                    NaNcount -= 1
                    solving_step += 1
                    print('Solving Step #',solving_step)
                    print('Set element',b_row+bx,',',b_col+by,'to',k,'as it was the only available spot in box',box,'for it')
                    print(possibilities_df)
      count +=1
    
    # Logic to look for tuples
    #logic to look for X-pairs
    #print(count)

#print(possibilities_df)
